## 异步和引用传递

```TypeScript
// mod
let a = 1;
export = { a };
```

```TypeScript
// entrance
import n from "mod";
import a1 from "rely1";
import a2 from "rely2";
console.log("a1", a1);
console.log("a2", a2);
console.log("n", n.a);

function delay(ms: number) {
  return new Promise( resolve => setTimeout(resolve, ms) );
}
delay(5000).then(() => {
  n.a += 5;
  console.log("nLast", n.a);
});
```

```TypeScript
// rely1
import n from "mod";
function delay(ms: number) {
  return new Promise( resolve => setTimeout(resolve, ms) );
}
delay(5000).then(() => {
  n.a += 5;
});
export = n.a;
```

```TypeScript
// rely2
import n from "mod";
n.a += 2;
export = n.a;
```

`rely1` 和 `rely2` 的区别在于，`rely1` 在导入之后，等待了 5 秒钟，然后才执行加法和打印。

```shell
a1 1
a2 3
n 3
# 等待若干时间后
nLast 8
```

从 entrance 入口开始，先导入 mod 再依次导入 rely1、rely2。
然后执行 entrnace 中的打印命令。

由于 rely1 中设置的延迟操作，因此没有立刻执行相加，就将相加前的数值 `export` 了。
紧接着进入 rely2，顺利执行了相加并 `export` 。
至此此时全部导入完毕，开始处理打印逻辑。

先打印 `a1 1` 作为第一个导入的结果，再打印 `a2 3` 作为第二个导入的结果；第三行打印的是 `n 3` 说明 rely2 中的修改，影响到了引用 mod 的 entrance。
之后等待若干时间后 rely1 的相加操作也执行完了；由于设置了同样的等待时间，我们保证 `nLast 8` 会出现在 rely1 执行之后。
数字 8 意味着 rely2 的操作同样影响到了引用了 mod 的 rely1；同理，rely1 的操作也影响到了 entrance。

**注意** relyN 返回的是 数字类型的 `n.a` 而不是对象 `n`；如果选择返回 `n`，那么表现出来的效果就会和 entrance 中的 `n` 一致。

## 重复导入只执行一次

```TypeScript
// mod
let a = 1;
console.log(a);  // 1
a += 1;
export = { a };
```

```TypeScript
// entrance
import n from "mod";
console.log(n.a);  //  2
import "rely";
```

```TypeScript
// rely
import n from "mod";
console.log(n.a);  // 3
```

在 mod 中有一条语句让 `a` 的数值改变，于是 entrance 中对应的 `a` 是这条语句执行后的值；
之后的 entrance 导入 rely，且 rely 中也导入同样的包，读取到的 `a` 是变化之后的数值。

**细节** rely 也导入了 mod，但是 mod 里面的 `a += 1` 只有在第一次被导入的时候才会执行一遍。

## 重名导入，后者覆盖前者

```TypeScript
// call module
import { a } from "mod";
```

```TypeScript
// mod
export * from "mod1";
export * from "mod2";
```

```TypeScript
// mod1
export const a = "a";
```

```TypeScript
// mod2
export const a = "A";
```

同名对象，被 `export *` 用法直接 re-export 时，可能会导致冲突。
TypeScript 处理冲突的方法是按照导入导出顺序覆盖。