---
Title: 防抖与节流
Tags: [JavaScript]
---

# 防抖与节流

---

## 背景

前端开发中，诸如 `resize`、`mousemove` 等等事件，会在短时间内频繁触发。
事件的处理函数也会因此被频繁调用，这在多数场景下，都是没有必要的。

为此，我们可以使用 **防抖** 和 **节流** 将事件处理函数的频率控制住。

## 防抖 debounce

### 原理

事件持续触发，但一段时间内只会执行一次事件处理函数。

```JavaScript
let wait = 1000;
let timerID;

function onEvent(event) {
  clearTimeout(timerID);
  timerID = setTimeout(() => {
    // do something
  }, wait);
}
```

`onEvent` 是一个事件处理函数，在 `evnet` 事件触发时执行；多次触发自然会多次执行。

为了实现防抖，需要在事件处理体之外，额外定义定时器 `timerID` 和 预设的延迟时间 `wait`。

`setTimeout` 是一个异步方法，它接受的第一个参数是函数，第二个是预设的延迟时间；返回值是定时器的编号，同一个对象的定时器共享编号池，每次自增。

`clearTimeout` 会根据传入的定时器编号清空对应的定时器。
注意：不会清空定时器编号 `timerID` 这个变量本身的值。

### 封装

上述写法很不完善，`timerID` 和 `wait` 处于事件处理函数的外层，意味着多个事件就要求手动创建多个定时器变量。
这很麻烦，因此封装一下。

```JavaScript
function debounce(func, wait) {
  let timerID;
  let returnFunc = function () {
    clearTimeout(timerID);
    timerID = setTimeout(func, wait);
  };
  return returnFunc;
}

// 真正的事件处理逻辑函数
function onEvent() {
  // do something
}

// 假定 变量 component 是需要被绑定的组件
component.onevent = debounce(onEvent, 1000);
```

组件显示绑定的事件处理函数指向了 `debounce(onEvent, 1000)` 返回的 `returnFunc`。

此后的每次的事件调用都不会进入 `debounce` 内部（即不会执行 `let timerID;` 语句），而是直接进入 `returnFunc`。
但是声明的 `timer` 不会被回收；由于闭包，它会被 `returnFunc` 用于持续记录定时器的编号以方便更新定时器。

此外，`returnFunc` 是不包含事件处理逻辑的，它只负责定时器的清除和设定。
真正负责事件处理的 `onEvent` 函数作为它的返回值，会由定时器间接控制执行。

```ascii
                                            +--------------------------+
                                            |         debounce         |
  +-----------+       +-------------+       | +-------+   +----------+ |        +-------+
  | component |------>+ EventHandle |       | | timer |   | (return) +-+------->+ Timer |
  +-----------+       +------+------+       | +-------+   +-----+----+ |        +---+---+
                             :              |                   ^      |            :
                             :              +-------------------+------+       +---------+
                             :                                  :              | onEvent |
                             +----------------------------------+              +---------+
```

### 修复 this 指向
 
正如上文所述，`returnFunc` 不包含事件处理逻辑，因此如果原本逻辑处理函数中如果使用了 `this` 关键字，则在 `setTimeout` 之后会丢失。
参考 [[this 指向问题#词法环境]] 。

修复方法：需要显式绑定 `this`。

```JavaScript
function debounce(func, wait) {
  let timerID;
  let returnFunc = function  () {
    let context = this;  // 引用正确的 this
    clearTimeout(timerID);
    timerID = setTimeout(function() {
      func.apply(context);  // 显式绑定
    }, wait);
  };
  return returnFunc;
}
```

### 修复 event 参数

事件处理函数会传入事件对象 `event` 作为事件处理逻辑的参数。

```JavaScript
function debounce(func, wait) {
  let timerID;
  let returnFunc = function () {
    let context = this;
    let args = arguments;  // 获取传入的 event 参数
    clearTimeout(timerID);
    timerID = setTimeout(function() {
      func.apply(context, args); // 显式绑定，同时将 args 传递给 func
    }, wait);
  };
  return returnFunc;
}
```

### 立即执行

一种常见的立即执行需求是只在连续事件开始时执行一次事件处理函数，之后的一段时间时间内不再执行。

```JavaScript
function debounce(func, wait, immediate) {
  let timerID;
  let returnFunc = function () {
    let context = this;
    let args = arguments;
    clearTimeout(timerID);
    if (immediate) {  // 需要立即执行的逻辑
      if (!timerID) {  // 根据定时器判断：有定时，表明事件触发中，不执行处理函数；反之，执行
        func.apply(context, args);
      }
      timerID = setTimeout(function() {
        timerID = null;  // 停止一段时间后，定时器编号清空，下次触发时，将立即执行处理函数
      }, wait);
    } else {  // 不需要立即执行时走的是原逻辑
      timerID = setTimeout(function() {
        func.apply(context, args);
      }, wait);
    }
  };
  return returnFunc;
}
```

可以调整定时器清空和标志位变化的时机，进而可以实现诸如 “开始结束各执行一次” 等更复杂的需求。

### 取消

取消主要依赖于清空定时器的操作。

```JavaScript
function debounce(func, wait) {
  let timerID;
  let returnFunc = function () {
    let context = this;
    let args = arguments;
    clearTimeout(timerID);
    timerID = setTimeout(function () {
      func.apply(context, args);
    }, wait);
  };

  // 将该函数绑定到执行取消操作的组件上即可
  returnFunc.cancel = function () {
    clearTimeout(timerID);
    // 如果需要结合立即执行的话还应清空定时器编号 timerID = null;
  };

  return returnFunc;
}
```

使用时，为了保证取消与防抖进入的是同一个词法环境，需要额外变量作存储。

```JavaScript
let func = debounce(onEvent, 1000);  // 需要赋值到公用的 func
component.onevent = func;
cancalComponent.onevent = func.cancel;
```

### 返回值

`setTimeout` 是异步方法，在上述例子中，只有 `immediate` 为 `true` 时才可以直接返回值，否则返回的都是 `undefined`。
因此推荐使用其他异步的回调函数主动处理需要的返回值。

## 节流 throttle

### 原理

事件持续触发，每隔一段时间就会执行一次事件处理函数。

### 使用时间戳

每次事件触发时，比较时间戳间隔判断是否应该执行。

```JavaScript
function throttle(func, wait) {
  let previous = 0;  // 储存上次事件处理执行后的时间戳
  let returnFunc = function () {
    let now = +new Date();  // 本次事件触发时的时间戳
    if (now - previous > wait) {
      func();  // 不存在 setTimeout 的词法环境，因此不需要显式绑定 this 或传递 arguments
      previous = now;  // 更新事件处理的时间戳
    }
  };
  return returnFunc;
}
```

上述代码预设了 `previous = 0`，因此会在事件刚开始触发时就立刻执行一次。

### 使用定时器

设置定时器，根据定时器是否存在判断事件处理函数能否执行。

```JavaScript
function throttle(func, wait) {
  let timerID;
  let previous = 0;
  let returnFunc = function () {
    let context = this;
    let args = arguments;
    // 不存在定时器时，设置并在时间到达后执行（以定时器的编号作为定时器存在的标准）
    if (!timerID) {
      timerID = setTimeout(function () {
        func.apply(context, args);
        timerID = null;  // 执行完成后清空计时器
      }, wait);
    }
  };
  return returnFunc;
}
```

上述代码没有设置 `immediate` 标志，故而会在事件触发一段时间后才执行第一次事件处理函数，并且事件停止触发一段时间后会再执行一次。

当考虑在定时器上设置立即执行的功能时，需要处理好 `timerID`，仔细设计第二次连续事件触发时的立即执行逻辑。

```ascii
  +----------------+ +-----------+
  | event_continue | | event_end |                              | 需要延迟执行吗?
  +----------------+ +-----------+                              v
                            |<------------- timer ------------->|
                                                 +----------------+ +-------------+
                                                 | event_continue | | event_begin |
                                                 +----------------+ +-------------+
                                                 ^
                                                 | 需要立即执行吗?
```

### 取消

使用类似的思路，根据使用的方案，清空定时器或 `previous` 值即可。

```JavaScript
  returnFunc.cancel = function () {
    clearTimeout(timerID);
    timerID = null;  // 使用了立即执行的逻辑时需要考虑清空 timerID
    // 或者
    previous = 0;
  };
```

## 总结

1. 防抖（debounce）连续的事件触发，视作一次，执行一次事件处理函数。预设的 `wait` 针对的是事件触发的间隔时间。
2. 节流（throttle）连续的事件触发，按时间间隔，有规律地执行若干次事件处理函数。预设的 `wait` 针对的是事件处理函数的间隔时间。
3. 使用定时器是需要注意 `this` 指向和 `event` 参数的问题。
4. 需要根据是否立即执行、是否需要取消等需求，灵活地变更代码。